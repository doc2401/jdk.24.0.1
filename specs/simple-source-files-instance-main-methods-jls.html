<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Simple Source Files and Instance main Methods (Fourth Preview)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <link rel="stylesheet" href="../resources/spec-changes.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>

<header id="title-block-header">
<div class="navbar"><div><strong>Java SE 24 & JDK 24</strong></div><nav><ul><li><a href="../api/index.html">API</a>
<li><a href="index.html">OTHER SPECIFICATIONS</a>
<li><a href="man/index.html">TOOL GUIDES</a></ul></nav></div>

<h1 class="title">Simple Source Files and Instance <code>main</code>
Methods (Fourth Preview)</h1>
<p class="subtitle">Changes to the Java® Language Specification •
Version 24.0.1+9-30</p>
</header>
<nav id="TOC" role="doc-toc" title="Table Of Contents">
<ul>
<li><a href="#jls-6" id="toc-jls-6">Chapter 6: Names</a>
<ul>
<li><a href="#jls-6.1" id="toc-jls-6.1">6.1 Declarations</a></li>
<li><a href="#jls-6.3" id="toc-jls-6.3">6.3 Scope of a
Declaration</a></li>
<li><a href="#jls-6.7" id="toc-jls-6.7">6.7 Fully Qualified Names and
Canonical Names</a></li>
</ul></li>
<li><a href="#jls-7" id="toc-jls-7">Chapter 7: Packages and Modules</a>
<ul>
<li><a href="#jls-7.3" id="toc-jls-7.3">7.3 Compilation Units</a></li>
<li><a href="#jls-7.4" id="toc-jls-7.4">7.4 Package Declarations</a>
<ul>
<li><a href="#jls-7.4.2" id="toc-jls-7.4.2">7.4.2 Unnamed
Packages</a></li>
</ul></li>
<li><a href="#jls-7.6" id="toc-jls-7.6">7.6 Top Level Class and
Interface Declarations</a></li>
</ul></li>
<li><a href="#jls-8" id="toc-jls-8">Chapter 8: Classes</a>
<ul>
<li><a href="#jls-8.1" id="toc-jls-8.1">8.1 Class Declarations</a>
<ul>
<li><a href="#jls-8.1.8" id="toc-jls-8.1.8"><strong>8.1.8 Implicitly
Declared Classes</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-12" id="toc-jls-12">Chapter 12: Execution</a>
<ul>
<li><a href="#jls-12.1" id="toc-jls-12.1">12.1 Java Virtual Machine
Startup</a>
<ul>
<li><a href="#jls-12.1.1" id="toc-jls-12.1.1">12.1.1 Load the
<strong>Initial</strong> Class <strong>or Interface</strong>
<del><code>Test</code></del></a></li>
<li><a href="#jls-12.1.2" id="toc-jls-12.1.2">12.1.2 Link <strong>the
Initial Class or Interface</strong> <del><code>Test</code></del>:
Verify, Prepare, (Optionally) Resolve</a></li>
<li><a href="#jls-12.1.3" id="toc-jls-12.1.3">12.1.3 Initialize
<strong>the Initial Class or Interface</strong> <del>Test</del>: Execute
Initializers</a></li>
<li><a href="#jls-12.1.4" id="toc-jls-12.1.4">12.1.4 Invoke
<del><code>Test.main</code></del> <strong>a <code>main</code>
method</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-13" id="toc-jls-13">Chapter 13: Binary
Compatibility</a>
<ul>
<li><a href="#jls-13.1" id="toc-jls-13.1">13.1 The Form of a
Binary</a></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a
href="https://docs.oracle.com/javase/specs/jls/se23/html">Java Language Specification</a>
to support <em>Simple Source Files and Instance <code>main</code>
Methods</em>, which is a preview feature of Java SE 24. See <a
href="https://openjdk.org/jeps/495">JEP 495</a> for an overview of the
feature.</p>
<p>This feature is co-developed with another feature, <em>Module Import
Declarations</em>. See <a
href="https://openjdk.org/jeps/494">JEP 494</a> for an overview of this
feature. This document assumes that changes described in a <a
href="module-import-declarations-jls.html">companion document</a> have
already been applied to the Java Language Specification.</p>
<p>A <a
href="simple-source-files-instance-main-methods-jvms.html">companion document</a>
describes the changes needed to the <a
href="https://docs.oracle.com/javase/specs/jvms/se23/html">Java Virtual Machine Specification</a>
to support Simple Source Files and Instance <code>main</code>
Methods.</p>
<p>Changes are described with respect to existing sections of the JLS.
New text is indicated <strong>like this</strong> and deleted text is
indicated <del>like this</del>. Explanation and discussion, as needed,
is set aside in grey boxes.</p>
<div class="editorial">
<p>Changelog:</p>
<p>2024-11-01: Added two new methods in class <code>java.io.IO</code>.
(<a href="#jls-7.3">7.3</a>)</p>
<p>2024-10: First draft of fourth preview. Main change from third
preview spec:</p>
<ul>
<li>Added missing section <a href="#jls-7.4.2">7.4.2</a></li>
</ul>
</div>
<h2 id="jls-6">Chapter 6: Names</h2>
<h3 id="jls-6.1">6.1 Declarations</h3>
<p><span id="jls-6.1-100"></span> A <em>declaration</em> introduces one
of the following entities into a program:</p>
<ul>
<li><p><span id="jls-6.1-100-A"></span> A module, declared in a
<code>module</code> declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7">7.7</a>)</p></li>
<li><p><span id="jls-6.1-100-B"></span> A package, declared in a
<code>package</code> declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.4">7.4</a>)</p></li>
<li><p><span id="jls-6.1-100-C"></span> An imported class or interface,
declared in a single-type-import declaration or a type-import-on-demand
declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5.1">7.5.1</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5.2">7.5.2</a>)</p></li>
<li><p><span id="jls-6.1-100-D"></span> An imported <code>static</code>
member, declared in a single-static-import declaration or a
static-import-on-demand declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5.3">7.5.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5.4">7.5.4</a>)</p></li>
<li><p><span id="jls-6.1-100-E"></span> A class, declared by a normal
class declaration (<a href="#jls-8.1">8.1</a>), an enum declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9">8.9</a>),
<del>or</del> a record declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.10">8.10</a>),
<strong>or implicitly by a simple compilation unit (<a
href="#jls-7.3">7.3</a>)</strong></p></li>
<li><p><span id="jls-6.1-100-F"></span> An interface, declared by a
normal interface declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-9.1">9.1</a>)
or an annotation interface declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.6">9.6</a>).</p></li>
<li><p><span id="jls-6.1-100-G"></span> A type parameter, declared as
part of the declaration of a generic class, interface, method, or
constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.1.2">8.1.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.1.2">9.1.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.4">8.4.4</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p><span id="jls-6.1-100-H"></span> A member of a reference type (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.2">8.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.2">9.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.3">8.9.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.6">9.6</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-10.html#jls-10.7">10.7</a>),
one of the following:</p>
<ul>
<li><p><span id="jls-6.1-100-H-A"></span> A member class (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.5">8.5</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p><span id="jls-6.1-100-H-B"></span> A member interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.5">8.5</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p><span id="jls-6.1-100-H-C"></span> A field, one of the
following:</p>
<ul>
<li><p><span id="jls-6.1-100-H-C-A"></span> A field declared in a class
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.3">8.3</a>)</p></li>
<li><p><span id="jls-6.1-100-H-C-B"></span> A field declared in an
interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.3">9.3</a>)</p></li>
<li><p><span id="jls-6.1-100-H-C-C"></span> An implicitly declared field
of a class corresponding to an enum constant or a record
component</p></li>
<li><p><span id="jls-6.1-100-H-C-D"></span> The field
<code>length</code>, which is implicitly a member of every array type
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-10.html#jls-10.7">10.7</a>)</p></li>
</ul></li>
<li><p><span id="jls-6.1-100-H-D"></span> A method, one of the
following:</p>
<ul>
<li><p><span id="jls-6.1-100-H-D-A"></span> A method
(<code>abstract</code> or otherwise) declared in a class (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
<li><p><span id="jls-6.1-100-H-D-B"></span> A method
(<code>abstract</code> or otherwise) declared in an interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p><span id="jls-6.1-100-H-D-C"></span> An implicitly declared
accessor method corresponding to a record component</p></li>
</ul></li>
</ul></li>
<li><p><span id="jls-6.1-100-I"></span> An enum constant (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p></li>
<li><p><span id="jls-6.1-100-J"></span> A record component (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.10.3">8.10.3</a>)</p></li>
<li><p><span id="jls-6.1-100-K"></span> A formal parameter, one of the
following:</p>
<ul>
<li><p><span id="jls-6.1-100-K-A"></span> A formal parameter of a method
of a class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.1">8.4.1</a>)</p></li>
<li><p><span id="jls-6.1-100-K-B"></span> A formal parameter of a
constructor of a class (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.1">8.8.1</a>)</p></li>
<li><p><span id="jls-6.1-100-K-C"></span> A formal parameter of a lambda
expression (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
</ul></li>
<li><p><span id="jls-6.1-100-L"></span> An exception parameter of an
exception handler declared in a <code>catch</code> clause of a
<code>try</code> statement (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
<li><p><span id="jls-6.1-100-M"></span> A local variable, one of the
following:</p>
<ul>
<li><p><span id="jls-6.1-100-M-A"></span> A local variable declared by a
local variable declaration statement in a block (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-14.html#jls-14.4.2">14.4.2</a>)</p></li>
<li><p><span id="jls-6.1-100-M-B"></span> A local variable declared by a
<code>for</code> statement or a <code>try</code>-with-resources
statement (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-14.html#jls-14.14">14.14</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p><span id="jls-6.1-100-M-C"></span> A local variable declared by a
pattern (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-14.html#jls-14.30.1">14.30.1</a>)</p></li>
</ul></li>
<li><p><span id="jls-6.1-100-N"></span> A local class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-14.html#jls-14.3">14.3</a>),
one of the following:</p>
<ul>
<li><p><span id="jls-6.1-100-N-A"></span> A local class declared by a
normal class declaration</p></li>
<li><p><span id="jls-6.1-100-N-B"></span> A local class declared by an
enum declaration</p></li>
<li><p><span id="jls-6.1-100-N-C"></span> A local class declared by an
record declaration</p></li>
<li><p><span id="jls-6.1-100-N-D"></span> A local interface declared by
a normal interface declaration</p></li>
</ul></li>
</ul>
<p><span id="jls-6.1-120"></span> Constructors (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8">8.8</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.10.4">8.10.4</a>)
are also introduced by declarations, but use the name of the class in
which they are declared rather than introducing a new name.</p>
<div class="editorial">
<p>The rest of this section is unchanged.</p>
</div>
<h3 id="jls-6.3">6.3 Scope of a Declaration</h3>
<p><span id="jls-6.3-100"></span> The <em>scope</em> of a declaration is
the region of the program within which the entity declared by the
declaration can be referred to using a simple name, provided it is not
shadowed (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html#jls-6.4.1">6.4.1</a>).</p>
<p><span id="jls-6.3-110"></span> A declaration is said to be <em>in
scope</em> at a particular point in a program if and only if the
declaration's scope includes that point.</p>
<p><span id="jls-6.3-200"></span> The scope of the declaration of an
observable top level package (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.4.3">7.4.3</a>)
is all observable compilation units associated with modules to which the
package is uniquely visible (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.4.3">7.4.3</a>).</p>
<p><span id="jls-6.3-210"></span> The declaration of a package that is
not observable is never in scope.</p>
<p><span id="jls-6.3-220"></span> The declaration of a subpackage is
never in scope.</p>
<p><span id="jls-6.3-230"></span> The package <code>java</code> is
always in scope.</p>
<p><span id="jls-6.3-240"></span> The scope of a class or interface
imported by a single-type-import declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5.1">7.5.1</a>)
or a type-import-on-demand declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5.2">7.5.2</a>)
is the module declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7">7.7</a>)
and all the class and interface declarations (<a
href="#jls-8.1">8.1</a>, <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-9.1">9.1</a>)
of the compilation unit in which the <code>import</code> declaration
appears, as well as any annotations on the module declaration or package
declaration of the compilation unit.</p>
<p><span id="jls-6.3-250"></span> The scope of a member imported by a
single-static-import declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5.3">7.5.3</a>)
or a static-import-on-demand declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5.4">7.5.4</a>)
is the module declaration and all the class and interface declarations
of the compilation unit in which the <code>import</code> declaration
appears, as well as any annotations on the module declaration or package
declaration of the compilation unit.</p>
<p><span id="jls-6.3-300"></span> The scope of a top level class or
interface (<a href="#jls-7.6">7.6</a>) <strong>declared in an ordinary
compilation unit</strong> is all class and interface declarations in the
package in which the top level class or interface is declared.</p>
<div class="inserted">
<p><span id="jls-6.3-ssf1"></span> The scope of the implicit declaration
of a top level class in a simple compilation unit (<a
href="#jls-7.3">7.3</a>) is empty; the class is never in scope.</p>
</div>
<p><span id="jls-6.3-305"></span> The scope of a declaration of a member
<em>m</em> declared in or inherited by a class or interface <em>C</em>
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.2">8.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.2">9.2</a>)
is the entire body of <em>C</em>, including any nested class or
interface declarations. If <em>C</em> is a record class, then the scope
of <em>m</em> additionally includes the header of the record declaration
of <em>C</em>.</p>
<div class="editorial">
<p>The rest of this section is unchanged.</p>
</div>
<h3 id="jls-6.7">6.7 Fully Qualified Names and Canonical Names</h3>
<p><span id="jls-6.7-100"></span> Every primitive type, named package,
top level class, and top level interface has a <em>fully qualified
name</em>:</p>
<ul>
<li><p><span id="jls-6.7-100-A"></span> The fully qualified name of a
primitive type is the keyword for that primitive type, namely
<code>byte</code>, <code>short</code>, <code>char</code>,
<code>int</code>, <code>long</code>, <code>float</code>,
<code>double</code>, or <code>boolean</code>.</p></li>
<li><p><span id="jls-6.7-100-B"></span> The fully qualified name of a
named package that is not a subpackage of a named package is its simple
name.</p></li>
<li><p><span id="jls-6.7-100-C"></span> The fully qualified name of a
named package that is a subpackage of another named package consists of
the fully qualified name of the containing package, followed by
"<code>.</code>", followed by the simple (member) name of the
subpackage.</p></li>
<li><p><span id="jls-6.7-100-D"></span> The fully qualified name of a
top level class or top level interface that is declared in an unnamed
package is the simple name of the class or interface.</p>
<blockquote>
<p><strong>In particular, this means that a top level class that is
implicitly declared by a simple compilation unit (<a
href="#jls-7.3">7.3</a>) has a fully qualified name, which is the simple
name determined by the host system (<a
href="#jls-8.1.8">8.1.8</a>).</strong></p>
</blockquote></li>
<li><p><span id="jls-6.7-100-E"></span> The fully qualified name of a
top level class or top level interface that is declared in a named
package consists of the fully qualified name of the package, followed by
"<code>.</code>", followed by the simple name of the class or
interface.</p></li>
</ul>
<p><span id="jls-6.7-110"></span> Each member class, member interface,
and array type <em>may</em> have a fully qualified name:</p>
<ul>
<li><p><span id="jls-6.7-110-A"></span> A member class or member
interface <em>M</em> of another class or interface <em>C</em> has a
fully qualified name if and only if <em>C</em> has a fully qualified
name.</p>
<p><span id="jls-6.7-110-A.1"></span> In that case, the fully qualified
name of <em>M</em> consists of the fully qualified name of <em>C</em>,
followed by "<code>.</code>", followed by the simple name of
<em>M</em>.</p></li>
<li><p><span id="jls-6.7-110-B"></span> An array type has a fully
qualified name if and only if its element type has a fully qualified
name.</p>
<p><span id="jls-6.7-110-B.1"></span> In that case, the fully qualified
name of an array type consists of the fully qualified name of the
component type of the array type followed by "<code>[]</code>".</p></li>
</ul>
<p><span id="jls-6.7-120"></span> A local class, local interface, or
anonymous class does not have a fully qualified name.</p>
<p><span id="jls-6.7-200"></span> Every primitive type, named package,
top level class, and top level interface has a <em>canonical
name</em>:</p>
<ul>
<li><p><span id="jls-6.7-200-A"></span> For every primitive type, named
package, top level class, and top level interface, the canonical name is
the same as the fully qualified name.</p>
<blockquote>
<p>In particular, this means that a top level class that is implicitly
declared by a simple compilation unit has a canonical name.</p>
</blockquote></li>
</ul>
<p><span id="jls-6.7-210"></span> Each member class, member interface,
and array type <em>may</em> have a canonical name:</p>
<ul>
<li><p><span id="jls-6.7-210-A"></span> A member class or member
interface <em>M</em> declared in another class or interface <em>C</em>
has a canonical name if and only if <em>C</em> has a canonical name.</p>
<p><span id="jls-6.7-210-A.1"></span> In that case, the canonical name
of <em>M</em> consists of the canonical name of <em>C</em>, followed by
"<code>.</code>", followed by the simple name of <em>M</em>.</p></li>
<li><p><span id="jls-6.7-210-B"></span> An array type has a canonical
name if and only if its component type has a canonical name.</p>
<p><span id="jls-6.7-210-B.1"></span> In that case, the canonical name
of the array type consists of the canonical name of the component type
of the array type followed by "<code>[]</code>".</p></li>
</ul>
<p><span id="jls-6.7-220"></span> A local class, local interface, or
anonymous class does not have a canonical name.</p>
<div class="example">
<p>Example 6.7-1. Fully Qualified Names</p>
<ul>
<li><p>The fully qualified name of the type <code>long</code> is
"<code>long</code>".</p></li>
<li><p>The fully qualified name of the package <code>java.lang</code> is
"<code>java.lang</code>" because it is subpackage <code>lang</code> of
package <code>java</code>.</p></li>
<li><p>The fully qualified name of the class <code>Object</code>, which
is defined in the package <code>java.lang</code>, is
"<code>java.lang.Object</code>".</p></li>
<li><p>The fully qualified name of the interface
<code>Enumeration</code>, which is defined in the package
<code>java.util</code>, is
"<code>java.util.Enumeration</code>".</p></li>
<li><p>The fully qualified name of the type "array of
<code>double</code>" is "<code>double[]</code>".</p></li>
<li><p>The fully qualified name of the type "array of array of array of
array of <code>String</code>" is
"<code>java.lang.String[][][][]</code>".</p></li>
</ul>
<p>In the code:</p>
<pre><code>package points;
class Point    { int x, y; }
class PointVec { Point[] vec; }</code></pre>
<p>the fully qualified name of the type <code>Point</code> is
"<code>points.Point</code>"; the fully qualified name of the type
<code>PointVec</code> is "<code>points.PointVec</code>"; and the fully
qualified name of the type of the field <code>vec</code> of class
<code>PointVec</code> is "<code>points.Point[]</code>".</p>
</div>
<div class="example">
<p>Example 6.7-2. Fully Qualified Names v. Canonical Name</p>
<p>The difference between a fully qualified name and a canonical name
can be seen in code such as:</p>
<pre><code>package p;
class O1 { class I {} }
class O2 extends O1 {}</code></pre>
<p>Both <code>p.O1.I</code> and <code>p.O2.I</code> are fully qualified
names that denote the member class <code>I</code>, but only
<code>p.O1.I</code> is its canonical name.</p>
</div>
<h2 id="jls-7">Chapter 7: Packages and Modules</h2>
<h3 id="jls-7.3">7.3 Compilation Units</h3>
<p><span id="jls-7.3-100"></span> <em>CompilationUnit</em> is the goal
symbol (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-2.html#jls-2.1">2.1</a>)
for the syntactic grammar (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-2.html#jls-2.3">2.3</a>)
of Java programs. It is defined by the following production:</p>
<dl>
<dt><em>CompilationUnit:</em></dt>
<dd>
<em>OrdinaryCompilationUnit</em>
</dd>
<dd>
<strong><em>SimpleCompilationUnit</em></strong>
</dd>
<dd>
<em>ModularCompilationUnit</em>
</dd>
<dt><em>OrdinaryCompilationUnit:</em></dt>
<dd>
[<em>PackageDeclaration</em>] {<em>ImportDeclaration</em>}
{<em>TopLevelClassOrInterfaceDeclaration</em>}
</dd>
</dl>
<div class="inserted">
<dl>
<dt><em>SimpleCompilationUnit:</em></dt>
<dd>
{<em>ImportDeclaration</em>} {<em>ClassMemberDeclarationNoMethod</em>}
<em>MethodDeclaration</em> {<em>ClassMemberDeclaration</em>}
</dd>
<dt><em>ClassMemberDeclarationNoMethod:</em></dt>
<dd>
<em>FieldDeclaration</em>
</dd>
<dd>
<em>ClassDeclaration</em>
</dd>
<dd>
<em>InterfaceDeclaration</em>
</dd>
<dd>
<code>;</code>
</dd>
</dl>
</div>
<dl>
<dt><em>ModularCompilationUnit:</em></dt>
<dd>
{<em>ImportDeclaration</em>} <em>ModuleDeclaration</em>
</dd>
</dl>
<p><span id="jls-7.3-120"></span> An <em>ordinary compilation unit</em>
consists of three parts, each of which is optional:</p>
<ul>
<li><p><span id="jls-7.3-120-A"></span> A <code>package</code>
declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.4">7.4</a>),
giving the fully qualified name (<a href="#jls-6.7">6.7</a>) of the
package to which the compilation unit belongs.</p>
<p><span id="jls-7.3-120-A.1"></span> A compilation unit that has no
<code>package</code> declaration is part of an unnamed package (<a
href="#jls-7.4.2">7.4.2</a>).</p></li>
<li><p><span id="jls-7.3-120-B"></span> <code>import</code> declarations
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.5">7.5</a>)
that allow classes and interfaces from other packages, and
<code>static</code> members of classes and interfaces, to be referred to
using their simple names.</p></li>
<li><p><span id="jls-7.3-120-C"></span> Top level declarations of
classes and interfaces (<a href="#jls-7.6">7.6</a>).</p></li>
</ul>
<div class="inserted">
<p><span id="jls-7.3-ssf1"></span></p>
<p>A <em>simple compilation unit</em> consists of a non-empty sequence
of class member declarations, at least one of which must be a method
declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4">8.4</a>),
optionally preceded by <code>import</code> declarations. Declarations of
methods, fields, classes, and interfaces are permitted in any order
after the <code>import</code> declarations (if any), as they would be in
a class body (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.1.7">8.1.7</a>).</p>
<blockquote>
<p>This means that the following compilation unit is unambiguously an
ordinary compilation unit:</p>
<pre><code>import p.*;
class Test { ... }</code></pre>
<p>whereas the following is unambiguously a simple compilation unit:</p>
<pre><code>import p.*;
static void main(){ ... }
class Test { ... }</code></pre>
</blockquote>
<p><span id="jls-7.3-ssf2"></span> A simple compilation unit implicitly
declares a top level class (<a href="#jls-7.6">7.6</a>) whose members
are the methods, fields, classes, and interfaces declared in the simple
compilation unit. The details of the class are specified in <a
href="#jls-8.1.8">8.1.8</a>.</p>
</div>
<p><span id="jls-7.3-130"></span> A <em>modular compilation unit</em>
consists of a <code>module</code> declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7">7.7</a>),
optionally preceded by <code>import</code> declarations. The
<code>import</code> declarations allow classes and interfaces from
packages in this module and other modules, as well as
<code>static</code> members of classes and interfaces, to be referred to
using their simple names within the <code>module</code> declaration.</p>
<p><span id="jls-7.3-200"></span> Every compilation unit implicitly
imports every <code>public</code> class or interface declared in the
predefined package <code>java.lang</code>, as if the declaration
<code>import java.lang.*;</code> appeared at the beginning of each
compilation unit immediately after any <code>package</code> declaration.
As a result, the names of all those classes and interfaces are available
as simple names in every compilation unit.</p>
<div class="inserted">
<p><span id="jls-7.3-ssf3"></span> Every simple compilation unit
implicitly imports on demand every <code>public</code> class or
interface declared in all the packages exported by the predefined module
<code>java.base</code>, as if the declaration
<code>import module java.base;</code> appeared at the beginning of each
simple compilation unit (<a
href="module-import-declarations-jls.html#jls-7.5.5">7.5.5</a>). As a
result, the names of all those classes and interfaces are available as
simple names in every simple compilation unit.</p>
<div class="editorial">
<p>The module import declaration feature is proposed by <a
href="https://openjdk.org/jeps/494">JEP 494</a> and specified in a <a
href="module-import-declarations-jls.html">companion document</a></p>
</div>
<p><span id="jls-7.3-ssf4"></span> Every simple compilation unit
implicitly imports all the <code>static</code> members from the class
<code>java.io.IO</code>, as if the declaration
<code>import static java.io.IO.*;</code> appeared at the beginning of
the simple compilation unit immediately after the declaration that
imports module <code>java.base;</code>. As a result, the names of all
those <code>static</code> members are available as simple names in every
simple compilation unit.</p>
<blockquote>
<p>The <code>java.io.IO</code> class declares the following five
<code>static</code> methods that provide for the most basic textual I/O
with the console:</p>
<pre><code>public static void println(Object obj) ...
public static void println() ...
public static void print(Object obj) ...
public static String readln(String prompt) ...
public static String readln() ...</code></pre>
<p>This allows code in a simple compilation unit to easily perform basic
interaction with the console without any import declarations. The simple
compilation unit corresponding to the famous "Hello World" program is as
follows:</p>
<pre><code>void main() {
   println(&quot;Hello, World!&quot;);
}</code></pre>
<p>and the simplest of interactive programs can be written as the
following simple compilation unit:</p>
<pre><code>void main() {
    String name = readln(&quot;Please enter your name: &quot;);
    print(&quot;Pleased to meet you, &quot;);
    println(name);
}</code></pre>
</blockquote>
</div>
<p><span id="jls-7.3-300"></span> The host system determines which
compilation units are <em>observable</em>, except for the compilation
units in the predefined package <code>java</code> and its subpackages
<code>lang</code> and <code>io</code>, which are all always
observable.</p>
<p><span id="jls-7.3-310"></span> Each observable compilation unit may
be <em>associated</em> with a module, as follows:</p>
<ul>
<li><p><span id="jls-7.3-310-A"></span> The host system may determine
that an observable ordinary compilation unit is associated with a module
chosen by the host system, except for (i) the ordinary compilation units
in the predefined package <code>java</code> and its subpackages
<code>lang</code> and <code>io</code>, which are all associated with the
<code>java.base</code> module, and (ii) any ordinary compilation unit in
an unnamed package, which is associated with a module as specified in <a
href="#jls-7.4.2">7.4.2</a>.</p></li>
<li><p><span id="jls-7.3-310-B"></span> The host system must determine
that an observable modular compilation unit is associated with the
module declared by the modular compilation unit.</p></li>
</ul>
<blockquote>
<p>The observability of a compilation unit influences the observability
of its package (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.4.3">7.4.3</a>),
while the association of an observable compilation unit with a module
influences the observability of that module (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7.6">7.7.6</a>).</p>
</blockquote>
<p><span id="jls-7.3-320"></span> When compiling the modular and
ordinary compilation units associated with a module <em>M</em>, the host
system must respect the dependencies specified in <em>M</em>'s
declaration. Specifically, the host system must limit the ordinary
compilation units that would otherwise be observable, to only those that
are <em>visible to M</em>. The ordinary compilation units that are
visible to <em>M</em> are the observable ordinary compilation units
associated with the modules that are <em>read by M</em>. The modules
read by <em>M</em> are given by the result of <em>resolution</em>, as
described in the <code>java.lang.module</code> package specification,
with <em>M</em> as the only root module. The host system must perform
resolution to determine the modules read by <em>M</em>; it is a
compile-time error if resolution fails for any of the reasons described
in the <code>java.lang.module</code> package specification.</p>
<blockquote>
<p>The readability relation is reflexive, so <em>M</em> reads itself,
and thus all of the modular and ordinary compilation units associated
with <em>M</em> are visible to <em>M</em>.</p>
</blockquote>
<blockquote>
<p>The modules read by <em>M</em> drive the packages that are uniquely
visible to <em>M</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.4.3">7.4.3</a>),
which in turn drives both the top level packages in scope and the
meaning of package names for code in the modular and ordinary
compilation units associated with <em>M</em> (<a
href="#jls-6.3">6.3</a>, <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html#jls-6.5.3">6.5.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html#jls-6.5.5">6.5.5</a>).</p>
</blockquote>
<blockquote>
<p>The rules above ensure that package and type names used in
annotations in a modular compilation unit (in particular, annotations
applied to the module declaration) are interpreted as if they appeared
in an ordinary compilation unit associated with the module.</p>
</blockquote>
<p><span id="jls-7.3-400"></span> Classes and interfaces declared in
different ordinary compilation units can refer to each other,
circularly. A Java compiler must arrange to compile all such classes and
interfaces at the same time.</p>
<h3 id="jls-7.4">7.4 Package Declarations</h3>
<h4 id="jls-7.4.2">7.4.2 Unnamed Packages</h4>
<p><span id="jls-7.4.2-100"></span> <del>An</del> <strong>A simple
compilation unit, or an</strong> ordinary compilation unit that has no
<code>package</code> declaration, but has at least one other kind of
declaration, is part of an <em>unnamed package</em>.</p>
<p><span id="jls-7.4.2-110"></span> Unnamed packages are provided by the
Java SE Platform principally for convenience when developing small or
temporary applications or when just beginning development.</p>
<p><span id="jls-7.4.2-120"></span> An unnamed package cannot have
subpackages, since the syntax of a <code>package</code> declaration
always includes a reference to a named top level package.</p>
<p><span id="jls-7.4.2-200"></span> An implementation of the Java SE
Platform must support at least one unnamed package. An implementation
may support more than one unnamed package, but is not required to do so.
Which ordinary compilation units are in each unnamed package is
determined by the host system.</p>
<p><span id="jls-7.4.2-210"></span> The host system must associate
ordinary compilation units in an unnamed package with an unnamed module
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7.5">7.7.5</a>),
not a named module.</p>
<div class="example">
<p>Example 7.4.2-1. Unnamed Package</p>
<p>The compilation unit:</p>
<pre><code>class FirstCall {
    public static void main(String[] args) {
        System.out.println(&quot;Mr. Watson, come here. &quot;
                           + &quot;I want you.&quot;);
    }
}</code></pre>
<p>defines a very <del>simple</del> <strong>basic</strong> compilation
unit as part of an unnamed package.</p>
</div>
<blockquote>
<p>In implementations of the Java SE Platform that use a hierarchical
file system for storing packages, one typical strategy is to associate
an unnamed package with each directory; only one unnamed package is
observable at a time, namely the one that is associated with the
"current working directory". The precise meaning of "current working
directory" depends on the host system.</p>
</blockquote>
<h3 id="jls-7.6">7.6 Top Level Class and Interface Declarations</h3>
<p><span id="jls-7.6-100"></span> A <em>top level class or interface
declaration</em> declares a top level class (<a href="#jls-8.1">8.1</a>)
or a top level interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-9.1">9.1</a>).</p>
<dl>
<dt><em>TopLevelClassOrInterfaceDeclaration:</em></dt>
<dd>
<em>ClassDeclaration</em>
</dd>
<dd>
<em>InterfaceDeclaration</em>
</dd>
<dd>
<code>;</code>
</dd>
</dl>
<blockquote>
<p>Extra "<code>;</code>" tokens appearing at the level of class and
interface declarations in a compilation unit have no effect on the
meaning of the compilation unit. Stray semicolons are permitted in the
Java programming language solely as a concession to C++ programmers who
are used to placing "<code>;</code>" after a class declaration. They
should not be used in new Java code.</p>
</blockquote>
<p><span id="jls-7.6-ssf1"></span> <strong>A top level class may also be
implicitly declared (<a href="#jls-8.1.8">8.1.8</a>) by a simple
compilation unit.</strong></p>
<p><span id="jls-7.6-120"></span> In the absence of an access modifier,
a top level class or interface has package access: it is accessible only
within ordinary compilation units of the package in which it is declared
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html#jls-6.6.1">6.6.1</a>).
A class or interface may be declared <code>public</code> to grant access
to the class or interface from code in other packages of the same
module, and potentially from code in packages of other modules.</p>
<p><span id="jls-7.6-200"></span> It is a compile-time error if a top
level class or interface declaration contains any one of the following
access modifiers: <code>protected</code>, <code>private</code>, or
<code>static</code>.</p>
<p><span id="jls-7.6-300"></span> It is a compile-time error if the name
of a top level class or interface appears as the name of any other top
level class or interface declared in the same package.</p>
<p><span id="jls-7.6-400"></span> The scope and shadowing of a top level
class or interface is specified in <a href="#jls-6.3">6.3</a> and <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html#jls-6.4">6.4</a>.</p>
<p><span id="jls-7.6-410"></span> The fully qualified name of a top
level class or interface is specified in <a href="#jls-6.7">6.7</a>.</p>
<div class="editorial">
<p>The rest of this section is unchanged.</p>
</div>
<h2 id="jls-8">Chapter 8: Classes</h2>
<h3 id="jls-8.1">8.1 Class Declarations</h3>
<p><span id="jls-8.1-100"></span> A <em>class declaration</em> specifies
a class.</p>
<p><span id="jls-8.1-110"></span> There are three kinds of class
declarations: <em>normal class declarations</em>, <em>enum
declarations</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9">8.9</a>),
and <em>record declarations</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.10">8.10</a>).</p>
<dl>
<dt><em>ClassDeclaration:</em></dt>
<dd>
<em>NormalClassDeclaration</em>
</dd>
<dd>
<em>EnumDeclaration</em>
</dd>
<dd>
<em>RecordDeclaration</em>
</dd>
<dt><em>NormalClassDeclaration:</em></dt>
<dd>
{<em>ClassModifier</em>} <code>class</code> <em>TypeIdentifier</em>
[<em>TypeParameters</em>]<br />
[<em>ClassExtends</em>] [<em>ClassImplements</em>]
[<em>ClassPermits</em>] <em>ClassBody</em>
</dd>
</dl>
<p><span id="jls-8.1-130"></span> <del>A class is also implicitly
declared by a class instance creation expression (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.9.5">15.9.5</a>)
and an enum constant that ends with a class body (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.1">8.9.1</a>).</del></p>
<p><span id="jls-8.1-ssf1"></span> <strong>Some classes are implicitly
declared by other constructs (<a
href="#jls-8.1.8">8.1.8</a>).</strong></p>
<p><span id="jls-8.1-200"></span> The <em>TypeIdentifier</em> in a class
declaration specifies the name of the class.</p>
<p><span id="jls-8.1-210"></span> It is a compile-time error if a class
has the same simple name as any of its enclosing classes or
interfaces.</p>
<p><span id="jls-8.1-300"></span> The scope and shadowing of a class
declaration is specified in <a href="#jls-6.3">6.3</a> and <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html#jls-6.4.1">6.4.1</a>.</p>
<h4 id="jls-8.1.8"><strong>8.1.8 Implicitly Declared
Classes</strong></h4>
<div class="inserted">
<p><span id="jls-8.1.8-ssf1"></span> Not all classes are specified by a
class declaration. The following constructs implicitly declare
classes:</p>
<ul>
<li><p><span id="jls-8.1.8-ssf1-A"></span> a class instance creation
expression that ends with a class body (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.9.5">15.9.5</a>)</p></li>
<li><p><span id="jls-8.1.8-ssf1-B"></span> an enum constant that ends
with a class body (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p></li>
<li><p><span id="jls-8.1.8-ssf1-C"></span> a simple compilation unit (<a
href="#jls-7.3">7.3</a>)</p></li>
</ul>
<p><span id="jls-8.1.8-ssf2"></span> In all cases, the members of any
implicitly declared class, including any implicitly declared members,
are subject to the usual rules for member declarations in a class.</p>
<blockquote>
<p>The following production from <a href="#jls-7.3">7.3</a> is shown
here for convenience:</p>
<dl>
<dt><em>SimpleCompilationUnit:</em></dt>
<dd>
{<em>ImportDeclaration</em>} {<em>ClassMemberDeclarationNoMethod</em>}
<em>MethodDeclaration</em> {<em>ClassMemberDeclaration</em>}
</dd>
<dt><em>ClassMemberDeclarationNoMethod:</em></dt>
<dd>
<em>FieldDeclaration</em>
</dd>
<dd>
<em>ClassDeclaration</em>
</dd>
<dd>
<em>InterfaceDeclaration</em>
</dd>
<dd>
<code>;</code>
</dd>
</dl>
</blockquote>
<p><span id="jls-8.1.8-ssf3"></span> The class implicitly declared by a
simple compilation unit satisfies the following properties:</p>
<ul>
<li><p><span id="jls-8.1.8-ssf3-A"></span> It is a top level class (<a
href="#jls-7.6">7.6</a>).</p></li>
<li><p><span id="jls-8.1.8-ssf3-B"></span> Its name is a valid
identifier (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-3.html#jls-3.8">3.8</a>)
determined by the host system.</p>
<blockquote>
<p>In simple implementations of the Java SE Platform, where compilation
units are stored in files, the name of this implicitly declared class
would typically be the name of the file containing the simple
compilation unit minus any extension (such as <code>.java</code> or
<code>.jav</code>).</p>
</blockquote></li>
<li><p><span id="jls-8.1.8-ssf3-C"></span> It is not
<code>abstract</code> (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.1.1.1">8.1.1.1</a>).</p></li>
<li><p><span id="jls-8.1.8-ssf3-D"></span> It is <code>final</code> (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>).</p></li>
<li><p><span id="jls-8.1.8-ssf3-E"></span> It is a member of an unnamed
package (<a href="#jls-7.4.2">7.4.2</a>) and has package
access.</p></li>
<li><p><span id="jls-8.1.8-ssf3-F"></span> Its direct superclass is
<code>Object</code> (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.1.4">8.1.4</a>).</p></li>
<li><p><span id="jls-8.1.8-ssf3-G"></span> It does not have any direct
superinterfaces (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.1.5">8.1.5</a>).</p></li>
<li><p><span id="jls-8.1.8-ssf3-H"></span> The body of the class
contains every class member declared in the simple compilation unit
(these are declarations of fields (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.3">8.3</a>),
methods (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4">8.4</a>),
member classes (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.5">8.5</a>),
and member interfaces (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.1.1.3">9.1.1.3</a>)).
It is not possible for a simple compilation unit to declare an instance
initializer (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.6">8.6</a>),
static initializer (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.7">8.7</a>),
or constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8">8.8</a>).</p></li>
<li><p><span id="jls-8.1.8-ssf3-I"></span> It has an implicitly declared
default constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.9">8.8.9</a>).</p></li>
</ul>
<p><span id="jls-8.1.8-ssf4"></span> It is a compile-time error if this
class does not declare a candidate <code>main</code> method (<a
href="#jls-12.1.4">12.1.4</a>).</p>
<blockquote>
<p>Note that an unnamed package may have multiple implicitly declared
classes as members.</p>
</blockquote>
</div>
<h2 id="jls-12">Chapter 12: Execution</h2>
<p><span id="jls-12-100"></span> This chapter specifies activities that
occur during execution of a program. It is organized around the life
cycle of the Java Virtual Machine and of the classes, interfaces, and
objects that form a program.</p>
<p><span id="jls-12-110"></span> The Java Virtual Machine starts up by
loading a specified class or interface, then invoking <del>the</del>
<strong>a</strong> method <code>main</code> in this specified class or
interface. Section <a href="#jls-12.1">12.1</a> outlines the loading,
linking, and initialization steps involved in executing
<code>main</code>, as an introduction to the concepts in this chapter.
Further sections specify the details of loading (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.2">12.2</a>),
linking (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.3">12.3</a>),
and initialization (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.4">12.4</a>).</p>
<p><span id="jls-12-120"></span> The chapter continues with a
specification of the procedures for creation of new class instances (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.5">12.5</a>);
and finalization of class instances (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.6">12.6</a>).
It concludes by describing the unloading of classes (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.7">12.7</a>)
and the procedure followed when a program exits (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.8">12.8</a>).</p>
<h3 id="jls-12.1">12.1 Java Virtual Machine Startup</h3>
<p><span id="jls-12.1-100"></span> The Java Virtual Machine starts
execution by invoking <del>the</del> <strong>a</strong> method
<code>main</code> of some specified class or interface. <strong>If this
<code>main</code> method has a formal parameter, it is passed</strong>
<del>passing it</del> a single argument which is an array of strings.
<del>In the examples in this specification, this first class is
typically called <code>Test</code>.</del></p>
<p><span id="jls-12.1-110"></span> The precise semantics of Java Virtual
Machine startup are given in Chapter 5 of <em>The Java Virtual Machine
Specification, Java SE 22 Edition</em>. Here we present an overview of
the process from the viewpoint of the Java programming language.</p>
<p><span id="jls-12.1-120"></span> The manner in which the initial class
or interface is specified to the Java Virtual Machine is beyond the
scope of this specification, but it is typical, in host environments
that use command lines, for the fully qualified name of the
<strong>initial</strong> class or interface to be specified as a command
line argument and for following command line arguments to be used as
strings to be provided as the argument to the method <code>main</code>.
<strong>If the original compilation unit was a simple compilation unit
(<a href="#jls-7.3">7.3</a>), then the name of the file that contained
the compilation unit, minus any extension, is typically used to specify
the name of the initial class or interface.</strong></p>
<blockquote>
<p>For example, in a UNIX implementation, the command line:</p>
<pre><code>java Test reboot Bob Dot Enzo</code></pre>
<p>will typically start a Java Virtual Machine by invoking method
<code>main</code> of class <code>Test</code> (a class in an unnamed
package), passing it an <strong>argument</strong> array containing the
four strings "<code>reboot</code>", "<code>Bob</code>",
"<code>Dot</code>", and "<code>Enzo</code>".</p>
</blockquote>
<div class="inserted">
<blockquote>
<p>Whereas if the file <code>HelloWorld.java</code> contained the
following simple compilation unit:</p>
<pre><code>void main() {
    System.out.println(&quot;Hello, World!&quot;);
}</code></pre>
<p>which has been compiled, then the command line:</p>
<pre><code>java HelloWorld</code></pre>
<p>will typically start a Java Virtual Machine by invoking the
<code>main</code> method of the implicitly declared class (<a
href="#jls-8.1.8">8.1.8</a>) producing the output:</p>
<pre><code>Hello, World!</code></pre>
</blockquote>
</div>
<p><span id="jls-12.1-130"></span> We now outline the steps the Java
Virtual Machine may take to execute <del><code>Test</code></del>
<strong>the initial class or interface</strong>, as an example of the
loading, linking, and initialization processes that are described
further in later sections.</p>
<h4 id="jls-12.1.1">12.1.1 Load the <strong>Initial</strong> Class
<strong>or Interface</strong> <del><code>Test</code></del></h4>
<p><span id="jls-12.1.1-100"></span> The initial attempt to execute
<del>the</del> <strong>a</strong> method <code>main</code> of
<strong>the initial</strong> class <strong>or interface</strong>
<del><code>Test</code></del> discovers that <del>the class
<code>Test</code></del> <strong>it</strong> is not loaded - that is,
that the Java Virtual Machine does not currently contain a binary
representation for this class <strong>or interface</strong>. The Java
Virtual Machine then uses a class loader to attempt to find such a
binary representation. If this process fails, then an error is thrown.
This loading process is described further in <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.2">12.2</a>.</p>
<h4 id="jls-12.1.2">12.1.2 Link <strong>the Initial Class or
Interface</strong> <del><code>Test</code></del>: Verify, Prepare,
(Optionally) Resolve</h4>
<p><span id="jls-12.1.2-100"></span> After <strong>the class or
interface</strong> <del><code>Test</code></del> is loaded, it must be
initialized before <strong>a method</strong> <code>main</code> can be
invoked. And <del><code>Test</code></del>, like all classes and
interfaces, <strong>it</strong> must be linked before it is initialized.
Linking involves verification, preparation, and (optionally) resolution.
Linking is described further in <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.3">12.3</a>.</p>
<p><span id="jls-12.1.2-110"></span> Verification checks that the loaded
representation of <strong>the class or interface</strong>
<del><code>Test</code></del> is well-formed, with a proper symbol table.
Verification also checks that the code that implements <strong>the class
or interface</strong> <del><code>Test</code></del> obeys the semantic
requirements of the Java programming language and the Java Virtual
Machine. If a problem is detected during verification, then an error is
thrown. Verification is described further in <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.3.1">12.3.1</a>.</p>
<p><span id="jls-12.1.2-120"></span> Preparation involves allocation of
static storage and any data structures that are used internally by the
implementation of the Java Virtual Machine, such as method tables.
Preparation is described further in <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.3.2">12.3.2</a>.</p>
<p><span id="jls-12.1.2-130"></span> Resolution is the process of
checking symbolic references from <strong>the class or
interface</strong> <del><code>Test</code></del> to other classes and
interfaces, by loading the other classes and interfaces that are
mentioned and checking that the references are correct.</p>
<p><span id="jls-12.1.2-140"></span> The resolution step is optional at
the time of initial linkage. An implementation may resolve symbolic
references from a class or interface that is being linked very early,
even to the point of resolving all symbolic references from the classes
and interfaces that are further referenced, recursively. (This
resolution may result in errors from these further loading and linking
steps.) This implementation choice represents one extreme and is similar
to the kind of "static" linkage that has been done for many years in
simple implementations of the C language. (In these implementations, a
compiled program is typically represented as an "<code>a.out</code>"
file that contains a fully-linked version of the program, including
completely resolved links to library routines used by the program.
Copies of these library routines are included in the
"<code>a.out</code>" file.)</p>
<p><span id="jls-12.1.2-150"></span> An implementation may instead
choose to resolve a symbolic reference only when it is actively used;
consistent use of this strategy for all symbolic references would
represent the "laziest" form of resolution. In this case, if <strong>the
class or interface</strong> <del><code>Test</code></del> had several
symbolic references to another class, then the references might be
resolved one at a time, as they are used, or perhaps not at all, if
these references were never used during execution of the program.</p>
<p><span id="jls-12.1.2-160"></span> The only requirement on when
resolution is performed is that any errors detected during resolution
must be thrown at a point in the program where some action is taken by
the program that might, directly or indirectly, require linkage to the
class or interface involved in the error. Using the "static" example
implementation choice described above, loading and linkage errors could
occur before the program is executed if they involved a class or
interface mentioned in the <strong>initial</strong> class <strong>or
interface</strong> <del><code>Test</code></del> or any of the further,
recursively referenced, classes and interfaces. In a system that
implemented the "laziest" resolution, these errors would be thrown only
when an incorrect symbolic reference is actively used.</p>
<p><span id="jls-12.1.2-170"></span> The resolution process is described
further in <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.3.3">12.3.3</a>.</p>
<h4 id="jls-12.1.3">12.1.3 Initialize <strong>the Initial Class or
Interface</strong> <del>Test</del>: Execute Initializers</h4>
<p><span id="jls-12.1.3-100"></span> In our continuing example, the Java
Virtual Machine is still trying to execute <del>the</del>
<strong>a</strong> method <code>main</code> of <strong>the
initial</strong> class <strong>or
interface</strong><del><code>Test</code></del>. This is permitted only
if the class has been initialized (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.4.1">12.4.1</a>).</p>
<p><span id="jls-12.1.3-110"></span> Initialization consists of
execution of any class variable initializers and static initializers of
the <strong>initial</strong> class <strong>or interface</strong>
<del><code>Test</code></del>, in textual order. But before
<strong>it</strong> <del><code>Test</code></del> can be initialized, its
direct superclass must be initialized, as well as the direct superclass
of its direct superclass, and so on, recursively. In the simplest case,
<strong>the initial class or interface</strong>
<del><code>Test</code></del> has <code>Object</code> as its implicit
direct superclass; if class <code>Object</code> has not yet been
initialized, then it must be initialized before <strong>the initial
class or interface</strong> <del><code>Test</code></del> is initialized.
Class <code>Object</code> has no superclass, so the recursion terminates
here.</p>
<p><span id="jls-12.1.3-120"></span> If <strong>the initial</strong>
class <strong>or interface</strong> <del><code>Test</code></del> has
another class <code>Super</code> as its superclass, then
<code>Super</code> must be initialized before <strong>the initial class
or interface</strong><del><code>Test</code></del>. This requires
loading, verifying, and preparing <code>Super</code> if this has not
already been done and, depending on the implementation, may also involve
resolving the symbolic references from <code>Super</code> and so on,
recursively.</p>
<p><span id="jls-12.1.3-130"></span> Initialization may thus cause
loading, linking, and initialization errors, including such errors
involving other classes and interfaces.</p>
<p><span id="jls-12.1.3-140"></span> The initialization process is
described further in <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.4">12.4</a>.</p>
<h4 id="jls-12.1.4">12.1.4 Invoke <del><code>Test.main</code></del>
<strong>a <code>main</code> method</strong></h4>
<p><span id="jls-12.1.4-100"></span> Finally, after completion of the
initialization for <strong>the initial</strong> class <strong>or
interface</strong> <del><code>Test</code></del> (during which other
consequential loading, linking, and initializing may have occurred),
<del>the</del> <strong>a <code>main</code></strong> method
<del><code>main</code> of</del> <strong> declared in or inherited by the
initial class or interface</strong> <del><code>Test</code></del> is
invoked.</p>
<div class="deleted">
<p><span id="jls-12.1.4-110"></span> The method <code>main</code> must
be declared <code>public</code>, <code>static</code>, and
<code>void</code>. It must specify a formal parameter (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.1">8.4.1</a>)
whose declared type is array of <code>String</code>. Therefore, either
of the following declarations is acceptable:</p>
<p><code>public static void main(String[] args)</code></p>
<p><code>public static void main(String... args)</code></p>
</div>
<div class="inserted">
<p><span id="jls-12.1.4-ssf1"></span> A method of the initial class or
interface is a <em>candidate</em> if it is named <code>main</code> and
one of the following applies:</p>
<ul>
<li><p><span id="jls-12.1.4-ssf1-A"></span> It has a single formal
parameter (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.1">8.4.1</a>)
whose declared type is an array of <code>String</code> and a
<code>void</code> result, and is with <code>public</code>,
<code>protected</code> or package access.</p></li>
<li><p><span id="jls-12.1.4-ssf1-B"></span> It has no formal parameters
and a <code>void</code> result, and is with <code>public</code>,
<code>protected</code> or package access.</p></li>
</ul>
<blockquote>
<p>Note that a candidate method may be either a <code>static</code> or
an instance method. A candidate method may also have a
<code>throws</code> clause (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.6">8.4.6</a>).</p>
<p>The form of a <code>main</code> method expanded significantly in Java
SE 24. Prior to that, it had to be <code>public</code>
<code>static</code> and have a single formal parameter; the only
variation possible was <code>String[]</code> versus
<code>String...</code> for the type of the single formal parameter. In
Java 24 and above, there are twelve possible forms, depending on the
access modifier, <code>static</code> modifier, and formal parameter.
This number increases to 18 if <code>String[]</code> is distinguished
from <code>String...</code> in the type of the single formal
parameter.</p>
<p>Note that it is <em>not</em> a compile-time error if the initial
class or interface counts more than one candidate method among its
members.</p>
<p>The presence of a candidate method in a class or interface may not be
immediately apparent because a <code>main</code> method may be
inherited. For example, a default method in an interface is an instance
method (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.4">9.4</a>),
so may be a candidate when inherited by a class that implements the
interface. Development tools are encouraged to highlight when a class or
interface has a member <code>main</code> method that could serve as the
start of the program.</p>
</blockquote>
<p><span id="jls-12.1.4-ssf2"></span> A <code>main</code> method of the
initial class or interface is invoked, as if by application of the
following rules:</p>
<ul>
<li><p><span id="jls-12.1.4-ssf2-A"></span> If there is a candidate
method with a single formal parameter then this method is invoked. If
the candidate method is <code>static</code> then it is invoked directly,
passing the argument array (<a href="#jls-12.1">12.1</a>). If the
candidate method is an instance method then it is invoked, passing the
argument array, on an instance of the initial class created by using a
constructor with no formal parameters and either <code>public</code>,
<code>protected</code>, or package access.</p></li>
<li><p><span id="jls-12.1.4-ssf2-B"></span> Otherwise, if there is a
candidate method with no formal parameters then this method is invoked.
If the candidate method is <code>static</code> then it is invoked
directly. If the candidate method is an instance method then it is
invoked on an instance of the initial class created by using a
constructor with no formal parameters and either <code>public</code>,
<code>protected</code>, or package access.</p></li>
</ul>
<blockquote>
<p>Note that it is not possible for a class to have both a
<code>static</code> and an instance method with the same signature (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.2">8.4.2</a>).</p>
<p>The behavior of an implementation if there is no candidate method to
invoke, or if there is no suitable constructor in the initial class when
invoking an instance candidate method, is beyond the scope of this
specification.</p>
</blockquote>
</div>
<h2 id="jls-13">Chapter 13: Binary Compatibility</h2>
<h3 id="jls-13.1">13.1 The Form of a Binary</h3>
<p><span id="jls-13.1-100"></span> Programs must be compiled either into
the <code>class</code> file format specified by <em>The Java Virtual
Machine Specification, Java SE 23 Edition</em>, or into a representation
that can be mapped into that format by a class loader written in the
Java programming language.</p>
<p><span id="jls-13.1-110"></span> A <code>class</code> file
corresponding to a class or interface declaration must have certain
properties. A number of these properties are specifically chosen to
support source code transformations that preserve binary compatibility.
The required properties are:</p>
<ol type="1">
<li><p><span id="jls-13.1-110-A"></span> The class or interface must be
named by its <em>binary name</em>, which must meet the following
constraints:</p>
<ul>
<li><p><span id="jls-13.1-110-A-A"></span> The binary name of a top
level class or interface (<a href="#jls-7.6">7.6</a>) is its canonical
name (<a href="#jls-6.7">6.7</a>).</p>
<div class="inserted">
<blockquote>
<p>Note that the canonical name of the top level class implicitly
declared by a simple compilation unit is determined by the host system
(<a href="#jls-8.1.8">8.1.8</a>).</p>
</blockquote>
</div></li>
<li><p><span id="jls-13.1-110-A-B"></span> The binary name of a member
class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.5">8.5</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.5">9.5</a>)
consists of the binary name of its immediately enclosing class or
interface, followed by <code>$</code>, followed by the simple name of
the member.</p></li>
<li><p><span id="jls-13.1-110-A-C"></span> The binary name of a local
class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-14.html#jls-14.3">14.3</a>)
consists of the binary name of its immediately enclosing class or
interface, followed by <code>$</code>, followed by a non-empty sequence
of digits, followed by the simple name of the local class.</p></li>
<li><p><span id="jls-13.1-110-A-D"></span> The binary name of an
anonymous class (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.9.5">15.9.5</a>)
consists of the binary name of its immediately enclosing class or
interface, followed by <code>$</code>, followed by a non-empty sequence
of digits.</p></li>
<li><p><span id="jls-13.1-110-A-E"></span> The binary name of a type
variable declared by a generic class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.1.2">8.1.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.1.2">9.1.2</a>)
is the binary name of its immediately enclosing class or interface,
followed by <code>$</code>, followed by the simple name of the type
variable.</p></li>
<li><p><span id="jls-13.1-110-A-F"></span> The binary name of a type
variable declared by a generic method (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.4">8.4.4</a>)
is the binary name of the class or interface declaring the method,
followed by <code>$</code>, followed by the descriptor of the method
(JVMS §4.3.3), followed by <code>$</code>, followed by the simple name
of the type variable.</p></li>
<li><p><span id="jls-13.1-110-A-G"></span> The binary name of a type
variable declared by a generic constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.4">8.8.4</a>)
is the binary name of the class declaring the constructor, followed by
<code>$</code>, followed by the descriptor of the constructor (JVMS
§4.3.3), followed by <code>$</code>, followed by the simple name of the
type variable.</p></li>
</ul></li>
<li><p><span id="jls-13.1-110-B"></span> A reference to another class or
interface must be symbolic, using the binary name of the class or
interface.</p></li>
<li><p><span id="jls-13.1-110-C"></span> A reference to a field that is
a constant variable (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-4.html#jls-4.12.4">4.12.4</a>)
must be resolved at compile time to the value <em>V</em> denoted by the
constant variable's initializer.</p>
<p><span id="jls-13.1-110-C.1"></span> If such a field is
<code>static</code>, then no reference to the field should be present in
the code in a binary file, including the class or interface which
declared the field. Such a field must always appear to have been
initialized (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.4.2">12.4.2</a>);
the default initial value for the field (if different than <em>V</em>)
must never be observed.</p>
<p><span id="jls-13.1-110-C.2"></span> If such a field is
non-<code>static</code>, then no reference to the field should be
present in the code in a binary file, except in the class containing the
field. (It will be a class rather than an interface, since an interface
has only <code>static</code> fields.) The class should have code to set
the field's value to <em>V</em> during instance creation (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-12.html#jls-12.5">12.5</a>).</p></li>
<li><p><span id="jls-13.1-110-D"></span> Given a legal expression
denoting a field access in a class <em>C</em>, referencing a field named
<em>f</em> that is not a constant variable and is declared in a
(possibly distinct) class or interface <em>D</em>, we define the
<em>qualifying class or interface of the field reference</em> as
follows:</p>
<ul>
<li><p><span id="jls-13.1-110-D-A"></span> If the expression is
referenced by a simple name, then if <em>f</em> is a member of the
current class or interface, <em>C</em>, then let <em>Q</em> be
<em>C</em>. Otherwise, let <em>Q</em> be the innermost lexically
enclosing class or interface declaration of which <em>f</em> is a
member. In either case, <em>Q</em> is the qualifying class or interface
of the reference.</p></li>
<li><p><span id="jls-13.1-110-D-B"></span> If the reference is of the
form <em>TypeName</em><code>.</code><em>f</em>, where <em>TypeName</em>
denotes a class or interface, then the class or interface denoted by
<em>TypeName</em> is the qualifying class or interface of the
reference.</p></li>
<li><p><span id="jls-13.1-110-D-C"></span> If the expression is of the
form <em>ExpressionName</em><code>.</code><em>f</em> or
<em>Primary</em><code>.</code><em>f</em>, then:</p>
<ul>
<li><p><span id="jls-13.1-110-D-C-A"></span> If the compile-time type of
<em>ExpressionName</em> or <em>Primary</em> is an intersection type
<em>V<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code>
<em>V<sub>n</sub></em> (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-4.html#jls-4.9">4.9</a>),
then the qualifying class or interface of the reference is the erasure
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-4.html#jls-4.6">4.6</a>)
of <em>V<sub>1</sub></em>.</p></li>
<li><p><span id="jls-13.1-110-D-C-B"></span> Otherwise, the erasure of
the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is
the qualifying class or interface of the reference.</p></li>
</ul></li>
<li><p><span id="jls-13.1-110-D-D"></span> If the expression is of the
form <code>super.</code><em>f</em>, then the superclass of <em>C</em> is
the qualifying class or interface of the reference.</p></li>
<li><p><span id="jls-13.1-110-D-E"></span> If the expression is of the
form <em>TypeName</em><code>.super.</code><em>f</em>, then the
superclass of the class denoted by <em>TypeName</em> is the qualifying
class or interface of the reference.</p></li>
</ul>
<p><span id="jls-13.1-110-D.1"></span> The reference to <em>f</em> must
be compiled into a symbolic reference to the qualifying class or
interface of the reference, plus the simple name of the field,
<em>f</em>.</p>
<p><span id="jls-13.1-110-D.2"></span> The reference must also include a
symbolic reference to the erasure of the declared type of the field, so
that the verifier can check that the type is as expected.</p></li>
<li><p><span id="jls-13.1-110-E"></span> Given a method invocation
expression or a method reference expression in a class or interface
<em>C</em>, referencing a method named <em>m</em> declared (or
implicitly declared (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.2">9.2</a>))
in a (possibly distinct) class or interface <em>D</em>, we define the
<em>qualifying class or interface of the method invocation</em> as
follows:</p>
<ul>
<li><p><span id="jls-13.1-110-E-A"></span> If <em>D</em> is
<code>Object</code> then the qualifying class or interface of the method
invocation is <code>Object</code>.</p></li>
<li><p><span id="jls-13.1-110-E-B"></span> Otherwise:</p>
<ul>
<li><p><span id="jls-13.1-110-E-B-A"></span> If the method is referenced
by a simple name, then if <em>m</em> is a member of the current class or
interface <em>C</em>, let <em>Q</em> be <em>C</em>; otherwise, let
<em>Q</em> be the innermost lexically enclosing class or interface
declaration of which <em>m</em> is a member. In either case, <em>Q</em>
is the qualifying class or interface of the method invocation.</p></li>
<li><p><span id="jls-13.1-110-E-B-B"></span> If the expression is of the
form <em>TypeName</em><code>.</code><em>m</em> or
<em>ReferenceType</em><code>::</code><em>m</em>, then the class or
interface denoted by <em>TypeName</em>, or the erasure of
<em>ReferenceType</em>, is the qualifying class or interface of the
method invocation.</p></li>
<li><p><span id="jls-13.1-110-E-B-C"></span> If the expression is of the
form <em>ExpressionName</em><code>.</code><em>m</em> or
<em>Primary</em><code>.</code><em>m</em> or
<em>ExpressionName</em><code>::</code><em>m</em> or
<em>Primary</em><code>::</code><em>m</em>, then:</p>
<ul>
<li><p><span id="jls-13.1-110-E-B-C-A"></span> If the compile-time type
of <em>ExpressionName</em> or <em>Primary</em> is an intersection type
<em>V<sub>1</sub></em> <code>&amp;</code> ... <code>&amp;</code>
<em>V<sub>n</sub></em>, then the qualifying class or interface of the
method invocation is the erasure of <em>V<sub>1</sub></em>.</p></li>
<li><p><span id="jls-13.1-110-E-B-C-B"></span> Otherwise, the erasure of
the compile-time type of <em>ExpressionName</em> or <em>Primary</em> is
the qualifying class or interface of the method invocation.</p></li>
</ul></li>
<li><p><span id="jls-13.1-110-E-B-D"></span> If the expression is of the
form <code>super.</code><em>m</em> or <code>super::</code><em>m</em>,
then the superclass of <em>C</em> is the qualifying class or interface
of the method invocation.</p></li>
<li><p><span id="jls-13.1-110-E-B-E"></span> If the expression is of the
form <em>TypeName</em><code>.super.</code><em>m</em> or
<em>TypeName</em><code>.super::</code><em>m</em>, then if
<em>TypeName</em> denotes a class <em>X</em>, the superclass of
<em>X</em> is the qualifying class or interface of the method
invocation; if <em>TypeName</em> denotes an interface <em>X</em>,
<em>X</em> is the qualifying class or interface of the method
invocation.</p></li>
</ul></li>
</ul>
<p><span id="jls-13.1-110-E.1"></span> A reference to a method must be
resolved at compile time to a symbolic reference to the qualifying class
or interface of the method invocation, plus the erasure of the declared
signature (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.2">8.4.2</a>)
of the method. The signature of a method must include all of the
following as determined by <a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.12.3">15.12.3</a>:</p>
<ul>
<li><p><span id="jls-13.1-110-E.1-A"></span> The simple name of the
method</p></li>
<li><p><span id="jls-13.1-110-E.1-B"></span> The number of parameters to
the method</p></li>
<li><p><span id="jls-13.1-110-E.1-C"></span> A symbolic reference to the
type of each parameter</p></li>
</ul>
<p><span id="jls-13.1-110-E.2"></span> A reference to a method must also
include either a symbolic reference to the erasure of the return type of
the denoted method or an indication that the denoted method is declared
<code>void</code> and does not return a value.</p></li>
<li><p><span id="jls-13.1-110-F"></span> Given a class instance creation
expression (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.9">15.9</a>)
or an explicit constructor invocation statement (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>)
or a method reference expression of the form <em>ClassType
<code>::</code> <code>new</code></em> (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.13">15.13</a>)
in a class or interface <em>C</em>, referencing a constructor <em>m</em>
declared in a (possibly distinct) class or interface <em>D</em>, we
define the <em>qualifying class of the constructor invocation</em> as
follows:</p>
<ul>
<li><p><span id="jls-13.1-110-F-A"></span> If the expression is of the
form <code>new</code> <em>D</em><code>(...)</code> or
<em>ExpressionName</em><code>.new</code> <em>D</em><code>(...)</code> or
<em>Primary</em><code>.new</code> <em>D</em><code>(...)</code> or
<em>D</em> <code>::</code> <code>new</code>, then the qualifying class
of the constructor invocation is <em>D</em>.</p></li>
<li><p><span id="jls-13.1-110-F-B"></span> If the expression is of the
form <code>new</code> <em>D</em><code>(...){...}</code> or
<em>ExpressionName</em><code>.new</code>
<em>D</em><code>(...){...}</code> or <em>Primary</em><code>.new</code>
<em>D</em><code>(...){...}</code>, then the qualifying class of the
constructor invocation is the anonymous class declared by the
expression.</p></li>
<li><p><span id="jls-13.1-110-F-C"></span> If the expression is of the
form <code>super(...)</code> or
<em>ExpressionName</em><code>.super(...)</code> or
<em>Primary</em><code>.super(...)</code>, then the qualifying class of
the constructor invocation is the direct superclass of
<em>C</em>.</p></li>
<li><p><span id="jls-13.1-110-F-D"></span> If the expression is of the
form <code>this(...)</code>, then the qualifying class of the
constructor invocation is <em>C</em>.</p></li>
</ul>
<p><span id="jls-13.1-110-F.1"></span> A reference to a constructor must
be resolved at compile time to a symbolic reference to the qualifying
class of the constructor invocation, plus the declared signature of the
constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.2">8.8.2</a>).
The signature of a constructor must include both:</p>
<ul>
<li><p><span id="jls-13.1-110-F.1-A"></span> The number of parameters of
the constructor</p></li>
<li><p><span id="jls-13.1-110-F.1-B"></span> A symbolic reference to the
type of each formal parameter</p></li>
</ul></li>
</ol>
<p><span id="jls-13.1-120"></span> A binary representation for a class
or interface must also contain all of the following:</p>
<ol type="1">
<li><p><span id="jls-13.1-120-A"></span> If it is a class and is not
<code>Object</code>, then a symbolic reference to the direct superclass
of this class.</p></li>
<li><p><span id="jls-13.1-120-B"></span> A symbolic reference to each
direct superinterface, if any.</p></li>
<li><p><span id="jls-13.1-120-C"></span> A specification of each field
declared in the class or interface, given as the simple name of the
field and a symbolic reference to the erasure of the type of the
field.</p></li>
<li><p><span id="jls-13.1-120-D"></span> If it is a class, then the
erased signature of each constructor, as described above.</p></li>
<li><p><span id="jls-13.1-120-E"></span> For each method declared in the
class or interface (excluding, for an interface, its implicitly declared
methods (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.2">9.2</a>)),
its erased signature and return type, as described above.</p></li>
<li><p><span id="jls-13.1-120-F"></span> The code needed to implement
the class or interface:</p>
<ul>
<li><p><span id="jls-13.1-120-F-A"></span> For an interface, code for
the field initializers and the implementation of each method with a
block body (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.4.3">9.4.3</a>).</p></li>
<li><p><span id="jls-13.1-120-F-B"></span> For a class, code for the
field initializers, the instance and static initializers, the
implementation of each method with a block body (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.4.7">8.4.7</a>),
and the implementation of each constructor.</p></li>
</ul></li>
<li><p><span id="jls-13.1-120-G"></span> Every class or interface must
contain sufficient information to recover its canonical name (<a
href="#jls-6.7">6.7</a>).</p></li>
<li><p><span id="jls-13.1-120-H"></span> Every member class or interface
must have sufficient information to recover its source-level access
modifier (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-6.html#jls-6.6">6.6</a>).</p></li>
<li><p><span id="jls-13.1-120-I"></span> Every nested class or interface
must have a symbolic reference to its immediately enclosing class or
interface (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.1.3">8.1.3</a>).</p></li>
<li><p><span id="jls-13.1-120-J"></span> Every class or interface must
contain symbolic references to all of its member classes and interfaces
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.5">8.5</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.5">9.5</a>),
and to all other nested classes and interfaces declared within its
body.</p></li>
<li><p><span id="jls-13.1-120-K"></span> A construct emitted by a Java
compiler must be marked as <em>synthetic</em> if it does not correspond
to a construct declared explicitly or implicitly in source code, unless
the emitted construct is a class initialization method (JVMS
§2.9).</p></li>
<li><p><span id="jls-13.1-120-L"></span> A construct emitted by a Java
compiler must be marked as <em>mandated</em> if it corresponds to a
formal parameter declared implicitly in source code (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.1">8.8.1</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.9">8.8.9</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.3">8.9.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>).</p></li>
</ol>
<blockquote>
<p>The following formal parameters are declared implicitly in source
code:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The first formal parameter of a constructor of a
non-<code>private</code> inner member class (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.1">8.8.1</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.9">8.8.9</a>).</p></li>
<li><p>The first formal parameter of an anonymous constructor of an
anonymous class whose superclass is an inner class (not in a static
context) (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>).</p></li>
<li><p>The formal parameter <code>name</code> of the
<code>valueOf</code> method which is implicitly declared in an enum
class (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.3">8.9.3</a>).</p></li>
<li><p>The formal parameters of a compact constructor of a record class
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.10.4">8.10.4</a>).</p></li>
</ul>
</blockquote>
<blockquote>
<p>For reference, the following constructs are declared implicitly in
source code, but are not marked as mandated because only formal
parameters and modules can be so marked in a <code>class</code> file
(JVMS §4.7.24, JVMS §4.7.25):</p>
</blockquote>
<blockquote>
<ul>
<li><p>Default constructors of normal and enum classes (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.8.9">8.8.9</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.2">8.9.2</a>)</p></li>
<li><p>Canonical constructors of record classes (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.10.4">8.10.4</a>)</p></li>
<li><p>Anonymous constructors (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>)</p></li>
<li><p>The <code>values</code> and <code>valueOf</code> methods of enum
classes (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>public</code> fields of enum classes (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>private</code> fields and <code>public</code>
methods of record classes (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-8.html#jls-8.10.3">8.10.3</a>)</p></li>
<li><p>Certain <code>public</code> methods of interfaces (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.2">9.2</a>)</p></li>
<li><p>Container annotations (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-9.html#jls-9.7.5">9.7.5</a>)</p></li>
<li><p><strong>Classes implicitly declared by a simple compilation unit
(<a href="#jls-8.1.8">8.1.8</a>).</strong></p></li>
</ul>
</blockquote>
<p><span id="jls-13.1-200"></span> A <code>class</code> file
corresponding to a module declaration must have the properties of a
<code>class</code> file for a class whose binary name is
<code>module-info</code> and which has no superclass, no
superinterfaces, no fields, and no methods. In addition, the binary
representation of the module must contain all of the following:</p>
<ul>
<li><p><span id="jls-13.1-200-A"></span> A specification of the name of
the module, given as a symbolic reference to the name indicated after
<code>module</code>. Also, the specification must include whether the
module is normal or open (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7">7.7</a>).</p></li>
<li><p><span id="jls-13.1-200-B"></span> A specification of each
dependence denoted by a <code>requires</code> directive, given as a
symbolic reference to the name of the module indicated by the directive
(<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7.1">7.7.1</a>).
Also, the specification must include whether the dependence is
<code>transitive</code> and whether the dependence is
<code>static</code>.</p></li>
<li><p><span id="jls-13.1-200-C"></span> A specification of each package
denoted by an <code>exports</code> or <code>opens</code> directive,
given as a symbolic reference to the name of the package indicated by
the directive (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7.2">7.7.2</a>).
Also, if the directive was qualified, the specification must give
symbolic references to the names of the modules indicated by the
directive's <code>to</code> clause.</p></li>
<li><p><span id="jls-13.1-200-D"></span> A specification of each service
denoted by a <code>uses</code> directive, given as a symbolic reference
to the name of the class or interface indicated by the directive (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7.3">7.7.3</a>).</p></li>
<li><p><span id="jls-13.1-200-E"></span> A specification of the service
providers denoted by a <code>provides</code> directive, given as
symbolic references to the names of the classes and interfaces indicated
by the directive's <code>with</code> clause (<a
href="https://docs.oracle.com/javase/specs/jls/se23/html/jls-7.html#jls-7.7.4">7.7.4</a>).
Also, the specification must give a symbolic reference to the name of
the class or interface indicated as the service by the
directive.</p></li>
</ul>
<p><span id="jls-13.1-300"></span> The following sections discuss
changes that may be made to class and interface declarations without
breaking compatibility with pre-existing binaries. Under the translation
requirements given above, the Java Virtual Machine and its
<code>class</code> file format support these changes. Any other valid
binary format, such as a compressed or encrypted representation that is
mapped back into <code>class</code> files by a class loader under the
above requirements, will necessarily support these changes as well.</p>
</main><footer class="legal-footer"><hr/><a href="../legal/copyright.html">Copyright</a> &copy; 1993, 2025, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java24speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 24.0.1+9-30 --></footer>
</body>
</html>